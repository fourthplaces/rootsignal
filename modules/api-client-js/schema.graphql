type ActiveWorkflow {
	workflowType: String!
	sourceId: String!
	status: String!
	"""
	Application-level stage (e.g. "scraping", "extracting", "discovering")
	"""
	stage: String
	createdAt: String
}

input CreateEntityInput {
	name: String!
	entityType: String!
	description: String
	website: String
}

input CreateServiceAreaInput {
	addressLocality: String!
	addressRegion: String!
}

input CreateServiceInput {
	entityId: UUID!
	name: String!
	description: String
}

"""
Implement the DateTime<Utc> scalar

The input/output is a string in RFC3339 format.
"""
scalar DateTime

enum FindingStatus {
	EMERGING
	ACTIVE
	DECLINING
	RESOLVED
}

enum FlagType {
	WRONG_TYPE
	WRONG_ENTITY
	EXPIRED
	SPAM
}

type GqlClusterDetail {
	id: UUID!
	clusterType: String!
	representativeContent: String!
	representativeAbout: String
	representativeSignalType: String!
	representativeConfidence: Float!
	representativeBroadcastedAt: DateTime
	signals: [GqlClusterSignal!]!
	entities: [GqlClusterEntity!]!
}

type GqlClusterEntity {
	id: UUID!
	name: String!
	entityType: String!
}

type GqlClusterSignal {
	id: UUID!
	signalType: String!
	content: String!
	confidence: Float!
	broadcastedAt: DateTime
}

type GqlConnection {
	id: UUID!
	fromType: String!
	fromId: UUID!
	toType: String!
	toId: UUID!
	role: String!
	causalQuote: String
	confidence: Float
	createdAt: DateTime!
}

type GqlContact {
	id: UUID!
	name: String
	title: String
	email: String
	telephone: String
	department: String
	createdAt: DateTime!
}

type GqlEntity {
	id: UUID!
	name: String!
	entityType: String!
	description: String
	website: String
	telephone: String
	email: String
	verified: Boolean!
	inLanguage: String!
	createdAt: DateTime!
	updatedAt: DateTime!
	tags: [GqlTag!]!
	locations: [GqlLocation!]!
	contacts: [GqlContact!]!
	schedules: [GqlSchedule!]!
	notes: [GqlNote!]!
	"""
	Number of signals associated with this entity.
	"""
	signalCount: Int!
	sources: [GqlSource!]!
	services: [GqlService!]!
	signals: [GqlSignal!]!
}

type GqlEntityConnection {
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	"""
	A list of edges.
	"""
	edges: [GqlEntityEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [GqlEntity!]!
}

"""
An edge in a connection.
"""
type GqlEntityEdge {
	"""
	The item at the end of the edge
	"""
	node: GqlEntity!
	"""
	A cursor for use in pagination
	"""
	cursor: String!
}

type GqlFinding {
	id: UUID!
	title: String!
	summary: String!
	status: String!
	validationStatus: String
	signalVelocity: Float
	investigationId: UUID
	triggerSignalId: UUID
	createdAt: DateTime!
	updatedAt: DateTime!
	evidence: [GqlFindingEvidence!]!
	connections(role: String): [GqlConnection!]!
	connectionCount: Int!
}

type GqlFindingConnection {
	nodes: [GqlFinding!]!
	totalCount: Int!
}

type GqlFindingEvidence {
	id: UUID!
	findingId: UUID!
	evidenceType: String!
	quote: String!
	attribution: String
	url: String
	pageSnapshotId: UUID
	createdAt: DateTime!
}

type GqlHeatMapPoint {
	id: UUID!
	latitude: Float!
	longitude: Float!
	weight: Float!
	entityType: String!
	entityId: UUID!
	signalType: String
	generatedAt: DateTime!
}

type GqlInvestigation {
	id: UUID!
	subjectType: String!
	subjectId: UUID!
	trigger: String!
	status: String!
	summaryConfidence: Float
	summary: String
	startedAt: DateTime
	completedAt: DateTime
	createdAt: DateTime!
	observations: [GqlObservation!]!
	"""
	Tool call steps from the investigation (ordered by step_number).
	"""
	steps: [GqlInvestigationStep!]!
	"""
	The finding produced by this investigation (if any).
	"""
	finding: GqlFinding
	"""
	The trigger signal that started this investigation.
	"""
	signal: GqlSignal
}

type GqlInvestigationStep {
	id: UUID!
	investigationId: UUID!
	stepNumber: Int!
	toolName: String!
	input: JSON!
	output: JSON!
	pageSnapshotId: UUID
	createdAt: DateTime!
}

type GqlLocation {
	id: UUID!
	name: String
	streetAddress: String
	addressLocality: String
	addressRegion: String
	postalCode: String
	latitude: Float
	longitude: Float
	locationType: String
	createdAt: DateTime!
}

type GqlMapCluster {
	id: UUID!
	latitude: Float!
	longitude: Float!
	memberCount: Int!
	dominantSignalType: String!
	representativeContent: String!
	representativeAbout: String
	signalCounts: GqlSignalTypeCounts!
	entityNames: [String!]!
}

type GqlNlqSearchResponse {
	parsed: GqlParsedQuery!
	results: GqlSearchResponse
}

type GqlNote {
	id: UUID!
	content: String!
	severity: String!
	sourceUrl: String
	sourceType: String
	isPublic: Boolean!
	author: String!
	expiredAt: DateTime
	createdAt: DateTime!
}

type GqlObservation {
	id: UUID!
	subjectType: String!
	subjectId: UUID!
	observationType: String!
	value: JSON!
	source: String!
	confidence: Float!
	investigationId: UUID
	observedAt: DateTime!
	reviewStatus: String!
}

type GqlPageSnapshot {
	id: UUID!
	pageUrl: String!
	url: String!
	contentHash: String!
	fetchedVia: String!
	contentPreview: String
	crawledAt: DateTime!
	scrapeStatus: String!
}

type GqlPageSnapshotDetail {
	id: UUID!
	sourceId: UUID
	url: String!
	canonicalUrl: String!
	contentHash: String!
	fetchedVia: String!
	html: String
	content: String
	metadata: JSON!
	crawledAt: DateTime!
	extractionStatus: String!
	extractionCompletedAt: DateTime
}

type GqlParsedFilters {
	signalDomain: String
	audienceRole: String
	category: String
	urgency: String
	capacityStatus: String
	radiusRelevant: String
	population: String
}

type GqlParsedQuery {
	searchText: String
	filters: GqlParsedFilters!
	temporal: GqlParsedTemporal
	intent: GqlSearchIntent!
	reasoning: String!
}

type GqlParsedTemporal {
	happeningOn: String
	happeningBetween: String
	dayOfWeek: String
}

type GqlSchedule {
	id: UUID!
	validFrom: DateTime
	validThrough: DateTime
	dtstart: String
	repeatFrequency: String
	byday: String
	bymonthday: String
	opensAt: NaiveTime
	closesAt: NaiveTime
	description: String
	createdAt: DateTime!
}

enum GqlSearchIntent {
	IN_SCOPE
	OUT_OF_SCOPE
	NEEDS_CLARIFICATION
	KNOWLEDGE_QUESTION
}

type GqlSearchResponse {
	results: [GqlSearchResult!]!
	totalEstimate: Int!
	mode: String!
	tookMs: Int!
}

type GqlSearchResult {
	id: UUID!
	title: String!
	description: String
	status: String!
	entityName: String
	entityType: String
	sourceUrl: String
	locationText: String
	createdAt: DateTime!
	inLanguage: String!
	locale: String!
	isFallback: Boolean!
	semanticScore: Float
	textScore: Float
	combinedScore: Float!
	distanceMiles: Float
	entity: GqlEntity
	tags: [GqlTag!]!
	locations: [GqlLocation!]!
	schedules: [GqlSchedule!]!
}

type GqlService {
	id: UUID!
	entityId: UUID!
	name: String!
	description: String
	status: String!
	url: String
	email: String
	telephone: String
	interpretationServices: String
	applicationProcess: String
	priceRange: String
	eligibility: String
	inLanguage: String!
	createdAt: DateTime!
	updatedAt: DateTime!
}

type GqlServiceArea {
	id: UUID!
	addressLocality: String!
	addressRegion: String!
	isActive: Boolean!
	createdAt: DateTime!
}

type GqlSignal {
	id: UUID!
	signalType: String!
	content: String!
	about: String
	entityId: UUID
	sourceUrl: String
	pageSnapshotId: UUID
	sourceCitationUrl: String
	confidence: Float!
	inLanguage: String!
	broadcastedAt: DateTime
	needsInvestigation: Boolean!
	investigationStatus: String
	investigationReason: String
	createdAt: DateTime!
	updatedAt: DateTime!
	locations: [GqlLocation!]!
	schedules: [GqlSchedule!]!
}

type GqlSignalConnection {
	nodes: [GqlSignal!]!
	totalCount: Int!
}

type GqlSignalStats {
	totalSignals: Int!
	totalSources: Int!
	totalSnapshots: Int!
	totalExtractions: Int!
	totalEntities: Int!
	signalsByType: [GqlTagCount!]!
	signalsByDomain: [GqlTagCount!]!
	recent7D: Int!
}

type GqlSignalTypeCounts {
	ask: Int!
	give: Int!
	event: Int!
	informative: Int!
}

type GqlSource {
	id: UUID!
	entityId: UUID
	name: String!
	url: String
	handle: String
	nextRunAt: DateTime
	consecutiveMisses: Int!
	lastScrapedAt: DateTime
	isActive: Boolean!
	config: JSON!
	contentSummary: String
	createdAt: DateTime!
	"""
	Derived source type based on the URL domain.
	"""
	sourceType: String!
	"""
	Number of signals extracted from this source's snapshots.
	"""
	signalCount: Int!
}

type GqlTag {
	id: UUID!
	kind: String!
	value: String!
	displayName: String
}

type GqlTagCount {
	value: String!
	count: Int!
}

type GqlTagKind {
	id: UUID!
	slug: String!
	displayName: String!
	description: String
	allowedResourceTypes: [String!]!
	required: Boolean!
	isPublic: Boolean!
	createdAt: DateTime!
}

type GqlTemporalDelta {
	zipCode: String!
	latitude: Float!
	longitude: Float!
	currentCount: Int!
	previousCount: Int!
	delta: Int!
	changePct: Float!
}

type GqlZipDensity {
	zipCode: String!
	addressLocality: String!
	latitude: Float!
	longitude: Float!
	signalCount: Int!
	signalDomainCounts: JSON!
}

"""
A scalar that can represent any JSON value.
"""
scalar JSON

"""
Merged mutation root composing all domain mutation modules.
"""
type MutationRoot {
	"""
	Send a verification code via SMS to the given phone number.
	"""
	sendVerificationCode(phone: String!): Boolean!
	"""
	Verify an OTP code and return a JWT token on success.
	"""
	verifyCode(phone: String!, code: String!): String!
	createEntity(input: CreateEntityInput!): GqlEntity!
	updateEntity(id: UUID!, input: UpdateEntityInput!): GqlEntity!
	archiveEntity(id: UUID!): GqlEntity!
	createService(input: CreateServiceInput!): GqlService!
	updateService(id: UUID!, input: UpdateServiceInput!): GqlService!
	discoverSocialLinks(entityId: UUID!): [GqlSource!]!
	reviewObservation(id: UUID!, decision: ReviewDecision!): GqlObservation!
	"""
	Trigger a scrape workflow for a specific source.
	"""
	triggerScrape(sourceId: UUID!): WorkflowTriggerResult!
	"""
	Trigger a full scrape cycle for all due sources.
	"""
	triggerScrapeCycle: WorkflowTriggerResult!
	"""
	Trigger extraction for a specific snapshot.
	"""
	triggerExtraction(snapshotId: UUID!): WorkflowTriggerResult!
	"""
	Trigger cluster detection scan for signal clusters that warrant investigation.
	"""
	triggerClusterDetection: WorkflowTriggerResult!
	"""
	Trigger translation for a specific record.
	"""
	triggerTranslation(translatableType: String!, translatableId: UUID!, locale: String!): WorkflowTriggerResult!
	"""
	Create a source from a URL or search query.
	The backend auto-detects source type, name, and handle from the input.
	Returns the existing source if the normalized URL already exists.
	"""
	addSource(input: String!): GqlSource!
	activateSources(ids: [UUID!]!): Int!
	deactivateSources(ids: [UUID!]!): Int!
	scrapeSources(ids: [UUID!]!): Int!
	deleteSources(ids: [UUID!]!): Int!
	"""
	Use AI to detect the entity behind a source from its scraped pages,
	then find-or-create the entity and link it to the source.
	"""
	detectSourceEntity(sourceId: UUID!): GqlEntity!
	createServiceArea(input: CreateServiceAreaInput!): GqlServiceArea!
	deleteServiceArea(id: UUID!): Boolean!
	"""
	Flag a signal for correction (wrong type, wrong entity, expired, spam).
	"""
	flagSignal(id: UUID!, flagType: FlagType!, suggestedType: SignalType, comment: String): Boolean!
	"""
	Delete all signals associated with a source.
	"""
	deleteSignalsBySource(sourceId: UUID!): Int!
	"""
	Manually trigger investigation for a signal.
	"""
	triggerInvestigation(signalId: UUID!): WorkflowTriggerResult!
	"""
	Admin override: update finding status.
	"""
	updateFindingStatus(id: UUID!, status: FindingStatus!): GqlFinding!
	"""
	Manually create a connection between nodes.
	"""
	createConnection(fromType: String!, fromId: UUID!, toType: String!, toId: UUID!, role: String!, causalQuote: String): GqlConnection!
	"""
	Recompute heat map points from current locationables, notes, and tags.
	"""
	recomputeHeatMap: Int!
}

"""
ISO 8601 time without timezone.
Allows for the nanosecond precision and optional leap second representation.
Format: %H:%M:%S%.f

# Examples

* `08:59:60.123`
"""
scalar NaiveTime

"""
Information about pagination in a connection
"""
type PageInfo {
	"""
	When paginating backwards, are there more items?
	"""
	hasPreviousPage: Boolean!
	"""
	When paginating forwards, are there more items?
	"""
	hasNextPage: Boolean!
	"""
	When paginating backwards, the cursor to continue.
	"""
	startCursor: String
	"""
	When paginating forwards, the cursor to continue.
	"""
	endCursor: String
}

"""
Merged query root composing all domain query modules.
"""
type QueryRoot {
	entity(id: UUID!): GqlEntity!
	entities(after: String, first: Int): GqlEntityConnection!
	"""
	List tags, optionally filtered by kind (e.g., "signal_domain", "category").
	"""
	tags(kind: String): [GqlTag!]!
	"""
	List all tag kind configurations (taxonomy metadata).
	"""
	tagKinds: [GqlTagKind!]!
	observation(id: UUID!): GqlObservation!
	pendingObservations(limit: Int! = 50): [GqlObservation!]!
	investigation(id: UUID!): GqlInvestigation!
	"""
	List investigations with optional status filter and pagination.
	"""
	investigations(status: String, subjectId: UUID, limit: Int! = 50, offset: Int! = 0): [GqlInvestigation!]!
	"""
	Count investigations, optionally by status.
	"""
	investigationCount(status: String): Int!
	heatMapPoints(zipCode: String, radiusMiles: Float, entityType: String, signalType: String): [GqlHeatMapPoint!]!
	"""
	Signal density aggregated by zip code.
	"""
	signalDensity(signalDomain: String, category: String): [GqlZipDensity!]!
	"""
	Signal gaps: zip codes with lowest signal coverage.
	"""
	signalGaps(signalDomain: String, category: String, limit: Int): [GqlZipDensity!]!
	"""
	Temporal comparison: signal trends over time.
	"""
	signalTrends(period: String!, signalDomain: String): [GqlTemporalDelta!]!
	"""
	Fetch clusters with location data for map display.
	"""
	signalClusters(signalType: String, since: String, minConfidence: Float, zipCode: String, radiusMiles: Float, about: String, limit: Int): [GqlMapCluster!]!
	"""
	Fetch a single cluster's detail for sidebar display.
	"""
	signalCluster(id: UUID!): GqlClusterDetail
	signalStats: GqlSignalStats!
	"""
	Hybrid search: combines semantic similarity (pgvector) with full-text search (tsvector).
	When `q` is provided, embeds the query and runs RRF-ranked hybrid search.
	When `q` is omitted, filters and sorts by relevance_score.
	"""
	search(q: String, signalDomain: String, audienceRole: String, category: String, urgency: String, confidence: String, capacityStatus: String, radiusRelevant: String, population: String, zipCode: String, radiusMiles: Float, lat: Float, lng: Float, radiusKm: Float, happeningOn: String, happeningBetween: String, dayOfWeek: String, limit: Int, offset: Int): GqlSearchResponse!
	"""
	Parse a natural language query into structured filters + search text.
	Optionally auto-executes the search when `auto_search` is true.
	"""
	parseQuery(q: String!, autoSearch: Boolean): GqlNlqSearchResponse!
	"""
	List active (non-completed) workflows, optionally filtered by source ID.
	"""
	activeWorkflows(sourceId: UUID): [ActiveWorkflow!]!
	"""
	Check the status of a running workflow.
	"""
	workflowStatus(workflowType: String!, workflowId: String!): String!
	sources: [GqlSource!]!
	source(id: UUID!): GqlSource!
	sourcePageSnapshots(sourceId: UUID!): [GqlPageSnapshot!]!
	pageSnapshot(id: UUID!): GqlPageSnapshotDetail!
	searchSources(q: String!): [GqlSource!]!
	serviceAreas: [GqlServiceArea!]!
	"""
	Fetch a single signal by ID.
	"""
	signal(id: UUID!): GqlSignal!
	"""
	Query signals with optional filters.
	"""
	signals(type: SignalType, entityId: UUID, sourceId: UUID, search: String, investigationStatus: String, lat: Float, lng: Float, radiusKm: Float, since: DateTime, limit: Int! = 50, offset: Int! = 0): GqlSignalConnection!
	"""
	Fetch a single finding by ID.
	"""
	finding(id: UUID!): GqlFinding!
	"""
	Query findings with optional filters.
	"""
	findings(status: FindingStatus, search: String, limit: Int! = 50, offset: Int! = 0): GqlFindingConnection!
	"""
	Query connections for a finding, optionally filtered by role.
	"""
	connections(findingId: UUID!, role: String): [GqlConnection!]!
}

enum ReviewDecision {
	APPROVE
	REJECT
}

enum SignalType {
	ASK
	GIVE
	EVENT
	INFORMATIVE
}

"""
A UUID is a unique 128-bit number, stored as 16 octets. UUIDs are parsed as
Strings within GraphQL. UUIDs are used to assign unique identifiers to
entities without requiring a central allocating authority.

# References

* [Wikipedia: Universally Unique Identifier](http://en.wikipedia.org/wiki/Universally_unique_identifier)
* [RFC4122: A Universally Unique Identifier (UUID) URN Namespace](http://tools.ietf.org/html/rfc4122)
"""
scalar UUID

input UpdateEntityInput {
	name: String
	description: String
	website: String
	telephone: String
	email: String
}

input UpdateServiceInput {
	name: String
	description: String
	url: String
	email: String
	telephone: String
}

type WorkflowTriggerResult {
	workflowId: String!
	status: String!
}

"""
Directs the executor to include this field or fragment only when the `if` argument is true.
"""
directive @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
"""
Directs the executor to skip this field or fragment when the `if` argument is true.
"""
directive @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
"""
Provides a scalar specification URL for specifying the behavior of custom scalar types.
"""
directive @specifiedBy(url: String!) on SCALAR
schema {
	query: QueryRoot
	mutation: MutationRoot
}
